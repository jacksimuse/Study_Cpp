# 생성자

1. 생성자
-클래스는 초기식을 쓰지 않고 객체를 초기화 하는 생성자라는 특별한 함수를 사용한다.
-생성자는 클래스 스스로 초기화 방법을 캡슐화하여 부품으로서의 완성도를 높이고 기본 타입과 동등해지는 장치이다.
-생성자는 컴파일러가 자동으로 호출하기 때문에 클래스와 이름이 같고 초기화만 담당해 리턴값은 없다.

2. 생성자 호출
- 명시적인 방법 : Human kim = Human("이름", 29);
- 암시적인 방법 : Human kim("이름", 29);

3. 생성자의 특징
-생성자는 함수의 일종이므로 인수를 받는다. 인수는 멤버와 유사한 이름을 사용하는 편이다.
-생성자는 오버로딩도 가능하다.

# 파괴자
파괴자
- 실시간으로 동적 할당을 해줘야하는 포인터를 사용하는 경우에 사용한다. 
동적 할당 시 생성자가 호출되며 객체의 동작을 위한 모든 것을 준비하는 임무를 띄기에 메모리할당, 라이브러리 로드, 네트워크나 데이터베이스의 외부환경까지 변경시키기 때문에 
이전 상태로 환경을 돌려 놓아야 시스템의 항상성이 유지된다. -> 객체 사용 후 파괴자로 생성자 이전의 상황으로 돌려놓기

- 생성자와 같은 이름을 쓰며 앞에 ~를 붙인다. 자동으로 호출되며 생성자와 다르게 받을 인수가 없으며 리턴값도 없다.

사용 예)
```C
Human(const char * aname, int aage){
  pname = new char[strlen(aname) + 1]; // 입력받은 문자열의 길이 + 1(널문자)만큼 동적할당(new) 해준다.
  strcpy(pname, aname);               // 멤버 변수에 입력 받은 것을 복사해준다.
  age = aage;
}
~Human(){ delete[] pname;}            // 파괴자로 동적할당한것만 삭제시킨다.
```

# 여러가지 생성자
1. 디폴트 생성자 : 인수를 받지 않으며 멤버함수에 무난한 값을 넣어주어 객체의 속성이 아니라 아직 초기화되지 않았다는 정도만 표시한다.
2. 복사 생성자 : 포인터를 사용하는 경우 그 주소를 가리키기 때문에 객체가 파괴될때 가리키는 주소가 없어지므로 다운된다. 그러므로 깊은 복사를 해줘야한다.
사용 예)
```C
Human(const Human &other) { // 다른 객체를 참조한다는 것으로 인수를 받아옴
  pname = new char[strlen(other.pname) + 1];  // 동적할당
  strcpy(pname, other.pname);                 // 참조 대상의 값을 복사
  age = other.age;                            // 복사본 완성 파괴자가 실행되도 복사객체는 살아있다.
}
```
